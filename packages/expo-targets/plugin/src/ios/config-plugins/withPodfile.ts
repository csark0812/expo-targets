import {
  ConfigPlugin,
  withDangerousMod,
  IOSConfig,
} from '@expo/config-plugins';
import path from 'path';

import { Podfile, File } from '../utils';

const { getProjectName } = IOSConfig.XcodeUtils;

export const withTargetPodfile: ConfigPlugin<{
  targetName: string;
  deploymentTarget: string;
  excludedPackages?: string[];
  standalone?: boolean;
}> = (config, props) => {
  return withDangerousMod(config, [
    'ios',
    async (config) => {
      const podfilePath = path.join(
        config.modRequest.platformProjectRoot,
        'Podfile'
      );
      let podfile = File.readFileIfExists(podfilePath);

      if (!podfile) {
        throw new Error(`Podfile not found at ${podfilePath}`);
      }

      // Remove existing target block if present (ensures correct placement on rebuild)
      if (Podfile.hasTargetBlock(podfile, props.targetName)) {
        console.log(
          `[expo-targets] Removing existing '${props.targetName}' target to ensure correct placement`
        );
        podfile = Podfile.removeTargetBlock(podfile, props.targetName);
      }

      // Only React Native extensions need main app to use_frameworks! (they inherit pods)
      // Standalone extensions are siblings and don't inherit, so they don't need this
      const projectRoot = config.modRequest.projectRoot;
      const mainTargetName = getProjectName(projectRoot);
      if (!props.standalone) {
        podfile = Podfile.ensureMainTargetUsesFrameworks(
          podfile,
          mainTargetName
        );
      }

      // Generate appropriate target block based on type
      // React Native targets are nested inside main target to inherit dependencies
      const targetBlock = props.standalone
        ? Podfile.generateStandaloneTargetBlock({
            targetName: props.targetName,
            deploymentTarget: props.deploymentTarget,
          })
        : Podfile.generateReactNativeTargetBlock({
            targetName: props.targetName,
            deploymentTarget: props.deploymentTarget,
          });

      console.log(
        `[expo-targets] Podfile: ${props.standalone ? 'standalone (sibling)' : 'React Native (nested)'} target: ${props.targetName}`
      );

      // Insert target block into Podfile
      // Standalone: sibling to avoid Expo autolinking, RN: nested to inherit
      podfile = Podfile.insertTargetBlock(
        podfile,
        targetBlock,
        props.standalone
      );

      // For standalone targets, inject deployment target fixes into post_install hook
      // Must be done in Podfile because xcconfig files are generated by CocoaPods
      if (props.standalone) {
        const extensionTargets: {
          targetName: string;
          deploymentTarget: string;
        }[] = [];
        const targetPattern =
          /target\s+'([^']+)'\s+do\s+platform\s+:ios,\s+'([^']+)'/g;
        let match;

        // Find all standalone extension targets in the Podfile (including the one we just inserted)
        while ((match = targetPattern.exec(podfile)) !== null) {
          const [, name, version] = match;
          if (name !== mainTargetName) {
            extensionTargets.push({
              targetName: name,
              deploymentTarget: version,
            });
          }
        }

        // Find the highest deployment target among all standalone extensions
        if (extensionTargets.length > 0) {
          const highestDeploymentTarget = extensionTargets.reduce((highest, ext) => {
            const extVersion = parseFloat(ext.deploymentTarget);
            const highestVersion = parseFloat(highest.deploymentTarget);
            return extVersion > highestVersion ? ext : highest;
          }).deploymentTarget;

          // Update Podfile platform line to match the highest extension deployment target
          // This ensures consistency and prevents linker errors
          podfile = Podfile.updatePodfilePlatform(podfile, highestDeploymentTarget);

          // Inject into post_install hook to fix after react_native_post_install runs
          podfile = Podfile.ensureExtensionDeploymentTargets(
            podfile,
            extensionTargets
          );
        }
      }

      File.writeFileSafe(podfilePath, podfile);
      return config;
    },
  ]);
};
